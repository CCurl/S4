************************************
*     S4 Reference                 *
************************************

*** ARITHMETIC ***
+  (a b--a+b)     addition
-  (a b--a-b)     subtraction
*  (a b--a*b)     multiplication
/  (a b--a/b)     division

*** BIT MANIPULATION ***
&  (a b--n)       and
|  (a b--n)       or
^  (a b--n)       xor
~  (n1--n2)       ones complement (10110010 => 01001101)

*** STACK ***
#  (a--a a)       Duplicate TOS (Forth DUP)
\  (a b--a)       Drop TOS (Forth DROP)
$  (a b--b a)     Swap top 2 stack items (Forth SWAP)
%  (a b--a b a)   Push 2nd (Forth OVER)

*** MEMORY ***
  NOTEs: There are 3 address spaces, CODE, MEMORY, and ABSOLUTE
         CODE and MEMORY addresses are indexes into that specific area of memory
         ABSOLUTE addresses are the addresses of the entire machine

        ** 8-bit operations: **
         these use 8-bit indexing and values
         E.G. - 28 c@ returns the lowest byte of HERE
c@    (a--n)      Fetch from MEMORY address a
c!    (n a--)     Store n to MEMORY address a
d@    (a--n)      Fetch from CODE address a
d!    (n a--)     Store n to CODE address a
m@    (a--n)      Fetch from ABSOLUTE address a
m!    (n a--)     Store n to ABSOLUTE address a

        ** 32-bit operations: **
         these use 32-bit indexing and values
         E.G. - 7 @ returns the 32-value of HERE
@     (a--n)      Fetch from MEMORY address a
!     (n a--)     Store n to MEMORY address a

*** REGISTERS ***
  NOTES: The registers are stored in MEMORY addresses [0..25]
         Register H is special: it is the HERE address
         Register initial values:
         - A: Size of CODE area
         - N: Size of FUNCTIONS array
         - Z: Size of MEMORY area
         - D: Start of CODE area
         - F: Start of FUNCTIONS array
         - M: Start of MEMORY area
         - R: Start of return stack
         - S: Start of data stack
         - Y: Start of system info sructure
         - All others set to 0
X   (--n)         Push value of register X (X:[A..Z])
X+  (--n)         Push value of register X, then increment the register by 1
X-  (--n)         Push value of register X, then decrement the register by 1
X;  (n--)         Store n to register X

*** FUNCTIONS ***
  NOTES: 1) Function names are exactly 2 characters, NOT case-sensitive
         2) The first character is ALPHA only [A..Z] or [a..z]
         3) The second character can be ALPHA or NUMERIC [0..9]
         4) A function cannot have '}' embedded in it (eg - {bd "TE}ST"} will not compile correctly)
            Use {ok "TE"125,"ST"} instead
{XX  (--)         Define function XX (XX:AA..z9)
}    (--)         End of function definition
:xx  (--)         Call function xx
;    (--)         Return from function immediately (i.e. - before reaching '}')
                    NOTE: returning while inside of a loop is not supported; behavior will be undefined.

*** INPUT/OUTPUT ***
.     (n--)       Output TOS as decimal number
,     (n--)       Output TOS (27 is ESC, 10 is newline, 65 is A, etc) (Forth emit)
b     (--)        Output a SPACE (32,)
r     (--)        Output a CR/LF (13,10,)
?     ( --key)    Read one key, don't wait for ENTER.
"     (--)        Output bytes until next '"'
_     (a1--a2)    String: copy string to address (a1) (eg - 1000_hello_)
                    Pushes address (a2) after terminating NULL
hX    (--n)       Scan HEX number (X) until non hex-digit (not case-sensitive h3Da0 == h3dA0 )
0..9  (--n)       Scan DECIMAL number until non digit
                     to specify multiple values, separate them by space (4711 3333)
                     to enter a negative number, use '~1+' (eg - '32~1+')
'x   (--n)        Push the ascii value of x (x: [any char possible])

*** CONDITIONS/FLOW CONTROL ***
<   (a b--f)      if (a < b), f=true, else f=false
>   (a b--f)      if (a > b), f=true, else f=false
=   (a b--f)      if (a = b), f=true, else f=false
(   (f--)         if (f != 0), execute code in '()', else skip until ')'
          NOTES: 1. You can NOT nest IFs
                 2. '()' cannot have ')' embedded in in (EG - a@("TE)ST"1-) fails when a=0)
                    USE a@("TE"41,"ST") instead
[   (f--f)        Begin while loop. If (f==0), skip code until ']'
]   (f--)         if (f != 0), repeat the loop, else drop f and continue.
          NOTES: 1. You can NOT nest LOOPs
                 2. '[]' cannot have ']' embedded in it (EG - a@["TE]ST"1-] fails when a=0)
                    USE a@("TE"93,"ST") instead

*** EXTENDED OPCODES ***
`FO   (fn md--fh)  File: open (fn/md: addr of name/mode, use `S"")
`FR   (fh--c n)    File: read 1 char (n=0 means EOF)
`FW   (c fh--)     File: write 1 char
`FC   (fh--)       File: close
`FNxx (--n)        Function: resolve function address (xx: function name)
`PI   (p--)        Arduino: pin input  (pinMode(p, INPUT))
`PU   (p--)        Arduino: pin pullup (pinMode(p, INPUT_PULLUP))
`PO   (p--)        Arduino: pin output (pinMode(p, OUTPUT)
`PRA  (p--n)       Arduino: pin read analog  (n = analogRead(p))
`PRD  (p--n)       Arduino: pin read digital (n = digitalRead(p))
`PWA  (n p--)      Arduino: pin write analog  (analogWrite(p, n))
`PWD  (n p--)      Arduino: pin write digital (digitalWrite(p, n))

*** OTHER ***
iA    (--)         Info: All (CFMRS)
iC    (--)         Info: Code
iF    (--)         Info: Functions
iM    (--)         Info: Memory
iR    (--)         Info: Registers
iS    (--)         Info: Stack
l     (n--)        Load code from block (block.nnn)
t     (--n)        Time (Arduino: millis(), Windows: GetTickCount())
w     (n--)        Wait (Arduino: delay(),  Windows: Sleep())
xA    (a--)        Call code at address A
xX    (--)         Reset S4 to initial state
xZ    (--)         Exit S4
