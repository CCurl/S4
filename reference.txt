S4 Reference

arithmetic
+  (a b--a+b)     addition
-  (a b--a-b)     subtraction
*  (a b--a*b)     multiplication
/  (a b--a/b)     division
%  (a b--a%b)     modulo (division remainder)
_  (n1--n2)       negate TOS (34 => -34)

bit manipulation
&  (a b--n)       32-bit and
|  (a b--n)       32-bit or
^  (a b--n)       32-bit xor
~  (n1-- n2)      not, all bits reversed (0110010 => 1001101)

stack
#  (a--a a)       Duplicate TOS (Forth DUP)
\  (a b--a)       Drop TOS (Forth DROP)
S  (a b--b a)     Swap top 2 stack items (Forth SWAP)
O  (a b--a b a)   Push next (Forth OVER)
++   (n1--n2)     Increment (TOS <- TOS+1)
--   (n1--n2)     Decrement (TOS <- TOS-1)

registers
x   (--)          Select register x (x: [a..z]). 
                  NOTE: Register stays selected until another register is selected.
@   (--n)         Fetch value from selected register
!   (n--)         Store value to selected register
x+  (--)          Select register x and increment it by 1
x-  (--)          Select register x and decrement it by 1

functions
{XX  (--)         Define function X (X: [A..9]|[a..9]). MUST be exactly 2 characters.
                  Example function names: AA, 35, Z4, F1, 4x, zz, z9
}    (--)         End of definition, return
:XX  (--)         Call function <X>
;    (--)         Return from function imediately (i.e. - before reaching '}')
                      NOTE: if used inside of a loop, behavior will be undefined

input/output
.    (n--)        print TOS as decimal number
,    (n--)        write TOS (27 is ESC, 10 is newline, etc) (Forth emit)
?    ( --key)     read key, don't wait for newline.
"    (--)         output bytes until next '"'
0..9 (--n)        scan decimal number until non digit. 
                      to push multiple values, separate them by space (4711 3333)
                      to enter a negative number use _ (negate) after the number

conditions
<   (a b--f)      if (a < b), f=-1, else f=0
>   (a b--f)      if (a > b), f=-1, else f=0
=   (a b--f)      if (a = b), f=-1, else f=0
(   (f--)         if (f != 0), execute until ')', if false skip until ')'
[   (f--f)        if (f != 0), begin while loop. Leave f on stack. Else, skip code until ']'
]   (f--)         if (f != 0), repeat the loop.

other
'x   (--n)        Push the ascii value of x (x: [any char possible])
AR   (p--n)       Arduino: read analog pin (v = analogRead(p))
AW   (n p--)      Arduino: write to analog pin (analogWrite(p, v))
B    (--)         Output a space
C@   (a--n)       Code: Fetch byte from address a
C!   (n a--)      Code: Store n (8-bit) to address a
DR   (p--n)       Arduino: read digital pin (n = digitalRead(p))
DW   (v p--)      Arduino: write to digital pin (digitalWrite(p, n))
F@   (?--)        Function fetch addr
F!   (?--)        Function: store addr
FO   (n a--)      File: open for reading (block.n)
FN   (n a--)      File: create new (block.n)
FC   (a--)        File: close
FR   (a--n)       File: read
FW   (n a--)      File: write
FF   (--f)        Flag: false
FT   (--t)        Flag: true
H@   (--n)        HERE: Fetch current value
H!   (n--)        HERE: Set HERE address
IA   (--)         Info: All (CFMRS)
IC   (--)         Info: Code
IF   (--)         Info: Functions
IM   (--)         Info: Memory
IR   (--)         Info: Registers
IS   (--)         Info: Stack
K    (n--n1)      Multiply TOS by 1000
M@   (a--n)       Memory: Fetch value from address a.
M!   (n a--)      Memory: Store n to address a.
PI   (p--)        Arduino: pinMode(p, INPUT)
PD   (p--)        Arduino: pinMode(p, INPUT_PULLDOWN)
PU   (p--)        Arduino: pinMode(p, INPUT_PULLUP)
PO   (p--)        Arduino: pinMode(p, OUTPUT)
R    (--)         Output a CR/LF
T    (--n)        Time (Arduino: millis(), Windows: GetTickCount())
W    (n--)        Wait (Arduino: delay(),  Windows: Sleep())
XX   (--)         Reset S4 to initial state
ZZ   (--)         Exit S4
