S4 Reference

arithmetic
+  (a b--a+b)     addition
-  (a b--a-b)     subtraction
*  (a b--a*b)     multiplication
/  (a b--a/b)     division
%  (a b--a%b)     modulo (division remainder)

bit manipulation
&  (a b--n)       32-bit and
|  (a b--n)       32-bit or
^  (a b--n)       32-bit xor
~  (n1-- n2)      not, all bits reversed (0110010 => 1001101)
_  (n1--n2)       negate TOS (17 => -17)

stack
#  (a--a a)       Duplicate TOS (Forth DUP)
\  (a b--a)       Drop TOS (Forth DROP)
$  (a b--b a)     Swap top 2 stack items (Forth SWAP)
:O  (a b--a b a)  Push next (Forth OVER)
:N  (a b--b)      Drop next (Forth NIP)

registers
x   (--)          Select register x (x: [a..z]). 
                  NOTE: the register stays selected until another register is selected.
@   (--n)         Fetch value from selected register
!   (n--)         Store value to selected register
x+  (--)          Select register x and increment it by 1
x-  (--)          Select register x and decrement it by 1

functions
{x   (--)         Define function x (x:A..Z)
}    (--)         End of function definition
x    (--)         Call function x (x:A..Z)
;    (--)         Return from function immediately (i.e. - before reaching '}')
                    NOTE: returning while inside of a loop is not supported; behavior will be undefined.

input/output
.     (n--)       Output TOS as decimal number
,     (n--)       Output TOS (27 is ESC, 10 is newline, 65 is A, etc) (Forth emit)
?     ( --key)    Read one key, don't wait for newline.
"     (--)        Output bytes until next '"'
0..9  (--n)       Scan decimal number until non digit. 
                     to speficy multiple values, separate them by space (4711 3333)
                     to enter a negative number, use _ (negate) after the number (eg - '32_')
'x   (--n)        Push the ascii value of x (x: [any char possible])

conditions
<   (a b--f)      if (a < b), f=true, else f=fales
>   (a b--f)      if (a > b), f=true, else f=false
=   (a b--f)      if (a = b), f=true, else f=false
(   (f--)         if (f != 0), execute code in '()', if false skip until ')'
[   (f--f)        if (f != 0), begin while loop. Leave f on stack. Else, skip code until ']'
]   (f--)         if (f != 0), repeat the loop. Else, drop f and continue.

other
:C@   (a--n)       Code: Fetch byte from address a
:C!   (n a--)      Code: Store n (8-bit) to address a
:FO   (n a--)      File: open for reading (block.n)
:FN   (n a--)      File: create new (block.n)
:FC   (a--)        File: close
:FR   (a--n)       File: read
:FW   (n a--)      File: write
:FF   (--f)        Flag: false
:FT   (--t)        Flag: true
:H@   (--n)        HERE: Fetch current value
:H!   (n--)        HERE: Set HERE address
:IA   (--)         Info: All (CFMRS)
:IC   (--)         Info: Code
:ID   (--)         Info: Dictionary
:IM   (--)         Info: Memory
:IR   (--)         Info: Registers
:IS   (--)         Info: Stack
:M@   (a--n)       Memory: Fetch value from address a.
:M!   (n a--)      Memory: Store n to address a.
:PI   (p--)        Arduino: pinMode(p, INPUT)
:PU   (p--)        Arduino: pinMode(p, INPUT_PULLUP)
:PO   (p--)        Arduino: pinMode(p, OUTPUT)
:PRA  (p--n)       Arduino: read analog pin (v = analogRead(p))
:PRD  (p--n)       Arduino: read digital pin (n = digitalRead(p))
:PWA  (n p--)      Arduino: write to analog pin (analogWrite(p, v))
:PWD  (v p--)      Arduino: write to digital pin (digitalWrite(p, n))
:T    (--n)        Time (Arduino: millis(), Windows: GetTickCount())
:W    (n--)        Wait (Arduino: delay(),  Windows: Sleep())
:XA   (a--)        Execute code at address A
:XX   (--)         Reset S4 to initial state
:ZZ   (--)         Exit S4
